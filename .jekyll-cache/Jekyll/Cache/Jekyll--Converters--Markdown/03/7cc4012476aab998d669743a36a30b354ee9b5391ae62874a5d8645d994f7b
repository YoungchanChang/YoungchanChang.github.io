I"<h1 id="언어마다-컨벤션이-있다">언어마다 컨벤션이 있다.</h1>

<h1 id="어떻게-해야-읽기-좋은-코드가-될까">어떻게 해야 읽기 좋은 코드가 될까?</h1>

<ul>
  <li>누가 봐도 읽기 좋은 코드가 되어야 한다.</li>
</ul>

<h3 id="이름-짓는-방법">이름 짓는 방법</h3>

<ul>
  <li>
    <p>언어마다 naming convention이 존재한다. 카멜케이스로 표기하되 클래스의 맨 앞문자는 대문자로 표기하고 변수, 삼수등은 소문자로 표기하는 등의 통용되는 규칙들이 존재한다.</p>
  </li>
  <li>
    <p>1.의도가 분명한 이름을 짓는다. 역할이 분명해야한다.</p>
  </li>
  <li>1-1) 줄여쓰지 않는다.</li>
  <li>
    <p>잘 알려진 축약어(ex&gt; CPU, for문에 i와 j)를 제외하고 축약어를 쓰지 말것(ex&gt; comp는 compare을 의미하는지 computer를 의미하는지 모른다.)</p>
  </li>
  <li>1-2) 애매한 단어를 쓰지 않는다.</li>
  <li>process 처리하다의 경우 무엇을 처리하는지 정확하지 않다. 무엇을 처리하는지 다른 단어를 쓰자.</li>
  <li>
    <p>유틸리티성 클래스는 추상적인 단어를 써도 적절하다.</p>
  </li>
  <li>1-3) 메소드의 경우 리턴값을 포함해서 이름을 짓는다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">return 'Empty' OR return list.get(0)</code>인 경우 getFirstElementorEmpty로 명시한다.</p>
  </li>
  <li>1-4) 단어의 뜻을 고류해서 이름을 짓는다.</li>
  <li>getX()는 존재한는 값을 가져올 때 쓴다. 없으면 에러가 뜬다. 반면, findY()는 찾아보고 없어도 된다.</li>
  <li>
    <p>initialize()는 객체의 상태를 최초로 설정한다. 반면, create()는 새 객체를 생성한다.</p>
  </li>
  <li>1-5) 단어의 이름은 통일되게 짓는다</li>
  <li>한 패키지에서 AuthenticationProvider로 지었다면 패키지 안의 클래스에서는 NotificationProvide로 짓는다.</li>
  <li>
    <p>productInfo, productData, productSummary로 나눠서 짓지 않는다.</p>
  </li>
  <li>1-6) 함수는 동사로 시작하고 목적어가 될 명사를 붙인다.</li>
  <li>boolean을 반환 하는 함수는 is, exists, has, use등으로 시작한다.</li>
  <li>boolean을 반환하는 함수는 긍정문으로 작성하자(if(isPossible()))</li>
</ul>

<h3 id="함수-작성법">함수 작성법</h3>

<ul>
  <li>1-1) 함수를 작게 만들기</li>
  <li>함수를 작게 만들수록 가독성과 유지보수에 좋다.</li>
  <li>유지 보수성을 위해서는 코드의 길이를 <strong>15줄 이내</strong>로 작성하자.</li>
  <li>
    <p><strong>수평방향 스크롤</strong>도 고려해서 개행하자.</p>
  </li>
  <li>1-2) 입력 형식에 대해서 제한을 둔다.</li>
  <li>
    <p>입력값을 검사하는 코드가 짧아진다.</p>
  </li>
  <li>1-3) 함수 내부도 추상화하라</li>
  <li>validateAndReport(){}메소드의 내부는 <code class="language-plaintext highlighter-rouge">validate(); report();</code>여야한다.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Reporter report = new Reporter(); report.report();</code>처럼 객체를 생성해서 메소드를 사용하지 말자.</p>
  </li>
  <li>1-4) 중괄호는 중첩을 피하자</li>
  <li>메서드당 들여쓰기는 깊이가 한 단계 이상 넘어가지 말아야 한다.</li>
  <li>이중 for문을 쓰는 경우 안의 포문은 다른 메소드로 대체하자.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 변경 전</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">VERTICAL_SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">HORIZONTAL_SIZE</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
        <span class="n">showCell</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 변경 후</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">VERTICAL_SIZE</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">showLine</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>1-5) 매개변수의 개수는 줄이자</li>
  <li>
    <p>매개변수가 많으면 가독성을 크게 저하시킨다.</p>
  </li>
  <li>1-6) 인자 유효성검사는 하자</li>
  <li>
    <p>함수 인자에 대해서는 유효성을 철저히 해야한다. 그러나 불필요한 검사나 중복 검사는 피해야한다.</p>
  </li>
  <li>1-7) 함수 배치에 신경쓰기</li>
  <li>
    <p>내부함수</p>
  </li>
  <li>단어의 이름 짓기</li>
  <li>구체적인 이름을 짓기()</li>
  <li>시작일과 시간에 대한 정보가 담겨있다면 StartDate -&gt; StartDateTime 와 같이 짓는다.</li>
  <li>one word for one abstract concept</li>
  <li>
    <p>한 개념당 하나의 이름을 짓기</p>
  </li>
  <li>함수의 이름 짓기</li>
  <li>동사 + 목적어로 표현한다.</li>
  <li>boolena반환은 is exists, has, use등으로 시작한다.</li>
  <li>
    <p>함수는 긍정형으로 짓는다(if(isReadable())))로 짓는 것이 좋다.</p>
  </li>
  <li>만약, 함수의 리턴값이 있다면 리턴값도 포함시켜서 짓기</li>
  <li>
    <p>불필요한 단어는 생략하기(매개변수로 들어오는 타입을 명시할 필요는 없다)</p>
  </li>
  <li>get은 주로 존재하는 값을 가져올 때 사용한다. find는 존재하지 않을 수 있는 값을 가져올 때 사용한다.</li>
  <li>getX()의 return값이 객체가 없다면 예외처리가 된다, findX()의</li>
  <li>initialize는 객체의 값을 초기화하고, create는 새 객체를 생성한다.</li>
  <li>
    <p>상반된 내용은 대칭적 단어를 쓰기(ex&gt; get/set, begin/end, pre/post)</p>
  </li>
  <li>
    <p>함수는 짧은 길이 짓기 ( why? )</p>
  </li>
  <li>소프트웨어 개선 그룹(SIG)의 유지 보수성 판정 통계에 따르면 유지 보수성이 훌륭한 프로그램에는 공통으로 길이가 15줄을 넘어가지 않은 함수가 대부분을 차지했다고 합니다.</li>
</ul>

<h1 id="함수-짓기">함수 짓기</h1>
<ul>
  <li>입력 값에 대해서 검증하기</li>
  <li>입력 형식에 제한을 두면 코드는 매우 간단해진다.</li>
  <li>중첩된 중괄호는 가독성을 떨어뜨린다.</li>
  <li>소트웍스 앤솔러지의 [객체지향 생활 체조]에서는 메서드 당 들여쓰기 깊이가 한 단계가 넘지 말아야 한다고 합니다</li>
  <li>매개변수 개수가 적어야 한다.</li>
  <li>가급적 if절에서 조건을 검사한 후 바로 리턴하거나 예외를 던지도록 코드를 수정해 else절을 없애 주는 게 중괄호 중첩을 막는 좋은 방법입니다.</li>
  <li>if 절에는 정상적인 상황에 대한 조건을 두고 비정상적인 상황을 else절에 두는 게 직관상 좋습니다.</li>
</ul>
:ET